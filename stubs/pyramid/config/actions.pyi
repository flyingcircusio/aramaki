from _typeshed import Incomplete
from collections.abc import Generator
from pyramid.exceptions import ConfigurationConflictError as ConfigurationConflictError, ConfigurationError as ConfigurationError, ConfigurationExecutionError as ConfigurationExecutionError
from pyramid.interfaces import IActionInfo as IActionInfo
from pyramid.registry import undefer as undefer
from pyramid.util import is_nonstr_iter as is_nonstr_iter, reraise as reraise

class ActionConfiguratorMixin:
    @property
    def action_info(self): ...
    def action(self, discriminator, callable: Incomplete | None = None, args=(), kw: Incomplete | None = None, order: int = 0, introspectables=(), **extra) -> None: ...
    action_state: Incomplete
    def commit(self) -> None: ...

class ActionState:
    actions: Incomplete
    def __init__(self) -> None: ...
    def processSpec(self, spec): ...
    def action(self, discriminator, callable: Incomplete | None = None, args=(), kw: Incomplete | None = None, order: int = 0, includepath=(), info: Incomplete | None = None, introspectables=(), **extra) -> None: ...
    def execute_actions(self, clear: bool = True, introspector: Incomplete | None = None): ...

class ConflictResolverState:
    resolved_ainfos: Incomplete
    remaining_actions: Incomplete
    min_order: Incomplete
    start: int
    def __init__(self) -> None: ...

def resolveConflicts(actions, state: Incomplete | None = None) -> Generator[Incomplete, None, Incomplete]: ...
def normalize_actions(actions): ...
def expand_action_tuple(discriminator, callable: Incomplete | None = None, args=(), kw: Incomplete | None = None, includepath=(), info: Incomplete | None = None, order: int = 0, introspectables=()): ...

class ActionInfo:
    file: Incomplete
    line: Incomplete
    function: Incomplete
    src: Incomplete
    def __init__(self, file, line, function, src) -> None: ...

def action_method(wrapped): ...
