from _typeshed import Incomplete
from collections.abc import Generator
from pkg_resources.extern import packaging
from pkg_resources.extern.jaraco.text import yield_lines as yield_lines
from pkgutil import get_importer as get_importer
from typing import NamedTuple

__all__ = ['require', 'run_script', 'get_provider', 'get_distribution', 'load_entry_point', 'get_entry_map', 'get_entry_info', 'iter_entry_points', 'resource_string', 'resource_stream', 'resource_filename', 'resource_listdir', 'resource_exists', 'resource_isdir', 'declare_namespace', 'working_set', 'add_activation_listener', 'find_distributions', 'set_extraction_path', 'cleanup_resources', 'get_default_cache', 'Environment', 'WorkingSet', 'ResourceManager', 'Distribution', 'Requirement', 'EntryPoint', 'ResolutionError', 'VersionConflict', 'DistributionNotFound', 'UnknownExtra', 'ExtractionError', 'PEP440Warning', 'parse_requirements', 'parse_version', 'safe_name', 'safe_version', 'get_platform', 'compatible_platforms', 'yield_lines', 'split_sections', 'safe_extra', 'to_filename', 'invalid_marker', 'evaluate_marker', 'ensure_directory', 'normalize_path', 'EGG_DIST', 'BINARY_DIST', 'SOURCE_DIST', 'CHECKOUT_DIST', 'DEVELOP_DIST', 'IMetadataProvider', 'IResourceProvider', 'FileMetadata', 'PathMetadata', 'EggMetadata', 'EmptyProvider', 'empty_provider', 'NullProvider', 'EggProvider', 'DefaultProvider', 'ZipProvider', 'register_finder', 'register_namespace_handler', 'register_loader_type', 'fixup_namespace_packages', 'get_importer', 'PkgResourcesDeprecationWarning', 'run_main', 'AvailableDistributions']

FileExistsError = OSError
require: Incomplete
working_set: Incomplete
add_activation_listener: Incomplete
cleanup_resources: Incomplete
resource_stream: Incomplete
set_extraction_path: Incomplete
resource_isdir: Incomplete
resource_string: Incomplete
iter_entry_points: Incomplete
resource_listdir: Incomplete
resource_filename: Incomplete
resource_exists: Incomplete

class PEP440Warning(RuntimeWarning): ...

parse_version: Incomplete

class ResolutionError(Exception): ...

class VersionConflict(ResolutionError):
    @property
    def dist(self): ...
    @property
    def req(self): ...
    def report(self): ...
    def with_context(self, required_by): ...

class ContextualVersionConflict(VersionConflict):
    @property
    def required_by(self): ...

class DistributionNotFound(ResolutionError):
    @property
    def req(self): ...
    @property
    def requirers(self): ...
    @property
    def requirers_str(self): ...
    def report(self): ...

class UnknownExtra(ResolutionError): ...

EGG_DIST: int
BINARY_DIST: int
SOURCE_DIST: int
CHECKOUT_DIST: int
DEVELOP_DIST: int

def register_loader_type(loader_type, provider_factory) -> None: ...
def get_provider(moduleOrReq): ...
get_platform = get_build_platform

def compatible_platforms(provided, required): ...
def run_script(dist_spec, script_name) -> None: ...
run_main = run_script

def get_distribution(dist): ...
def load_entry_point(dist, group, name): ...
def get_entry_map(dist, group: Incomplete | None = None): ...
def get_entry_info(dist, group, name): ...

class IMetadataProvider:
    def has_metadata(name) -> None: ...
    def get_metadata(name) -> None: ...
    def get_metadata_lines(name) -> None: ...
    def metadata_isdir(name) -> None: ...
    def metadata_listdir(name) -> None: ...
    def run_script(script_name, namespace) -> None: ...

class IResourceProvider(IMetadataProvider):
    def get_resource_filename(manager, resource_name) -> None: ...
    def get_resource_stream(manager, resource_name) -> None: ...
    def get_resource_string(manager, resource_name) -> None: ...
    def has_resource(resource_name) -> None: ...
    def resource_isdir(resource_name) -> None: ...
    def resource_listdir(resource_name) -> None: ...

class WorkingSet:
    entries: Incomplete
    entry_keys: Incomplete
    by_key: Incomplete
    normalized_to_canonical_keys: Incomplete
    callbacks: Incomplete
    def __init__(self, entries: Incomplete | None = None) -> None: ...
    def add_entry(self, entry) -> None: ...
    def __contains__(self, dist) -> bool: ...
    def find(self, req): ...
    def iter_entry_points(self, group, name: Incomplete | None = None): ...
    def run_script(self, requires, script_name) -> None: ...
    def __iter__(self): ...
    def add(self, dist, entry: Incomplete | None = None, insert: bool = True, replace: bool = False) -> None: ...
    def resolve(self, requirements, env: Incomplete | None = None, installer: Incomplete | None = None, replace_conflicting: bool = False, extras: Incomplete | None = None): ...
    def find_plugins(self, plugin_env, full_env: Incomplete | None = None, installer: Incomplete | None = None, fallback: bool = True): ...
    def require(self, *requirements): ...
    def subscribe(self, callback, existing: bool = True) -> None: ...

class _ReqExtras(dict):
    def markers_pass(self, req, extras: Incomplete | None = None): ...

class Environment:
    platform: Incomplete
    python: Incomplete
    def __init__(self, search_path: Incomplete | None = None, platform=..., python=...) -> None: ...
    def can_add(self, dist): ...
    def remove(self, dist) -> None: ...
    def scan(self, search_path: Incomplete | None = None) -> None: ...
    def __getitem__(self, project_name): ...
    def add(self, dist) -> None: ...
    def best_match(self, req, working_set, installer: Incomplete | None = None, replace_conflicting: bool = False): ...
    def obtain(self, requirement, installer: Incomplete | None = None): ...
    def __iter__(self): ...
    def __iadd__(self, other): ...
    def __add__(self, other): ...
AvailableDistributions = Environment

class ExtractionError(RuntimeError): ...

class ResourceManager:
    extraction_path: Incomplete
    cached_files: Incomplete
    def __init__(self) -> None: ...
    def resource_exists(self, package_or_requirement, resource_name): ...
    def resource_isdir(self, package_or_requirement, resource_name): ...
    def resource_filename(self, package_or_requirement, resource_name): ...
    def resource_stream(self, package_or_requirement, resource_name): ...
    def resource_string(self, package_or_requirement, resource_name): ...
    def resource_listdir(self, package_or_requirement, resource_name): ...
    def extraction_error(self) -> None: ...
    def get_cache_path(self, archive_name, names=()): ...
    def postprocess(self, tempname, filename) -> None: ...
    def set_extraction_path(self, path) -> None: ...
    def cleanup_resources(self, force: bool = False) -> None: ...

def get_default_cache(): ...
def safe_name(name): ...
def safe_version(version): ...
def safe_extra(extra): ...
def to_filename(name): ...
def invalid_marker(text): ...
def evaluate_marker(text, extra: Incomplete | None = None): ...

class NullProvider:
    egg_name: Incomplete
    egg_info: Incomplete
    loader: Incomplete
    module_path: Incomplete
    def __init__(self, module) -> None: ...
    def get_resource_filename(self, manager, resource_name): ...
    def get_resource_stream(self, manager, resource_name): ...
    def get_resource_string(self, manager, resource_name): ...
    def has_resource(self, resource_name): ...
    def has_metadata(self, name): ...
    def get_metadata(self, name): ...
    def get_metadata_lines(self, name): ...
    def resource_isdir(self, resource_name): ...
    def metadata_isdir(self, name): ...
    def resource_listdir(self, resource_name): ...
    def metadata_listdir(self, name): ...
    def run_script(self, script_name, namespace) -> None: ...

class EggProvider(NullProvider):
    def __init__(self, module) -> None: ...

class DefaultProvider(EggProvider):
    def get_resource_stream(self, manager, resource_name): ...

class EmptyProvider(NullProvider):
    module_path: Incomplete
    def __init__(self) -> None: ...

empty_provider: Incomplete

class ZipManifests(dict):
    @classmethod
    def build(cls, path): ...
    load = build

class MemoizedZipManifests(ZipManifests):

    class manifest_mod(NamedTuple):
        manifest: Incomplete
        mtime: Incomplete
    def load(self, path): ...

class ZipProvider(EggProvider):
    eagers: Incomplete
    zip_pre: Incomplete
    def __init__(self, module) -> None: ...
    @property
    def zipinfo(self): ...
    def get_resource_filename(self, manager, resource_name): ...

class FileMetadata(EmptyProvider):
    path: Incomplete
    def __init__(self, path) -> None: ...
    def has_metadata(self, name): ...
    def get_metadata(self, name): ...
    def get_metadata_lines(self, name): ...

class PathMetadata(DefaultProvider):
    module_path: Incomplete
    egg_info: Incomplete
    def __init__(self, path, egg_info) -> None: ...

class EggMetadata(ZipProvider):
    zip_pre: Incomplete
    loader: Incomplete
    module_path: Incomplete
    def __init__(self, importer) -> None: ...

def register_finder(importer_type, distribution_finder) -> None: ...
def find_distributions(path_item, only: bool = False): ...

class NoDists:
    def __bool__(self) -> bool: ...
    def __call__(self, fullpath): ...

def register_namespace_handler(importer_type, namespace_handler) -> None: ...
def declare_namespace(packageName) -> None: ...
def fixup_namespace_packages(path_item, parent: Incomplete | None = None) -> None: ...
def normalize_path(filename): ...

class EntryPoint:
    name: Incomplete
    module_name: Incomplete
    attrs: Incomplete
    extras: Incomplete
    dist: Incomplete
    def __init__(self, name, module_name, attrs=(), extras=(), dist: Incomplete | None = None) -> None: ...
    def load(self, require: bool = True, *args, **kwargs): ...
    def resolve(self): ...
    def require(self, env: Incomplete | None = None, installer: Incomplete | None = None) -> None: ...
    pattern: Incomplete
    @classmethod
    def parse(cls, src, dist: Incomplete | None = None): ...
    @classmethod
    def parse_group(cls, group, lines, dist: Incomplete | None = None): ...
    @classmethod
    def parse_map(cls, data, dist: Incomplete | None = None): ...

class Distribution:
    PKG_INFO: str
    project_name: Incomplete
    py_version: Incomplete
    platform: Incomplete
    location: Incomplete
    precedence: Incomplete
    def __init__(self, location: Incomplete | None = None, metadata: Incomplete | None = None, project_name: Incomplete | None = None, version: Incomplete | None = None, py_version=..., platform: Incomplete | None = None, precedence=...) -> None: ...
    @classmethod
    def from_location(cls, location, basename, metadata: Incomplete | None = None, **kw): ...
    @property
    def hashcmp(self): ...
    def __hash__(self): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    @property
    def key(self): ...
    @property
    def parsed_version(self): ...
    @property
    def version(self): ...
    def requires(self, extras=()): ...
    def activate(self, path: Incomplete | None = None, replace: bool = False) -> None: ...
    def egg_name(self): ...
    def __getattr__(self, attr): ...
    def __dir__(self): ...
    @classmethod
    def from_filename(cls, filename, metadata: Incomplete | None = None, **kw): ...
    def as_requirement(self): ...
    def load_entry_point(self, group, name): ...
    def get_entry_map(self, group: Incomplete | None = None): ...
    def get_entry_info(self, group, name): ...
    def insert_on(self, path, loc: Incomplete | None = None, replace: bool = False) -> None: ...
    def check_version_conflict(self) -> None: ...
    def has_version(self): ...
    def clone(self, **kw): ...
    @property
    def extras(self): ...

class EggInfoDistribution(Distribution): ...

class DistInfoDistribution(Distribution):
    PKG_INFO: str
    EQEQ: Incomplete

def parse_requirements(strs): ...

class RequirementParseError(packaging.requirements.InvalidRequirement): ...

class Requirement(packaging.requirements.Requirement):
    unsafe_name: Incomplete
    specs: Incomplete
    extras: Incomplete
    hashCmp: Incomplete
    def __init__(self, requirement_string) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __contains__(self, item) -> bool: ...
    def __hash__(self): ...
    @staticmethod
    def parse(s): ...

def ensure_directory(path) -> None: ...
def split_sections(s) -> Generator[Incomplete, None, None]: ...

class PkgResourcesDeprecationWarning(Warning): ...
